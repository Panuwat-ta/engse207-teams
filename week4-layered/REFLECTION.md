# การสะท้อนคิด สัปดาห์ที่ 4: Layered Architecture

## 1. สิ่งที่เรียนรู้

ได้เรียนรู้หลักการของ Layered Architecture และ Separation of Concerns (SoC) อย่างเป็นรูปธรรม ทำให้เข้าใจว่าการแบ่งโค้ดออกเป็นชั้นๆ (Presentation, Business, Data Access) ช่วยให้โค้ดมีระเบียบและจัดการง่ายขึ้นอย่างไร นอกจากนี้ยังได้เรียนรู้วิธีการสื่อสารระหว่าง Layer ผ่าน Interface ที่ชัดเจน (เช่น Controller เรียก Service, Service เรียก Repository)

## 2. ข้อดีที่พบจากการทำจริง

ข้อดีที่เห็นได้ชัดที่สุดคือความชัดเจนของโค้ด เมื่อต้องการแก้ไข Logic ที่เกี่ยวกับการติดต่อฐานข้อมูล ก็สามารถตรงไปที่ `taskRepository.js` ได้ทันที หรือถ้าต้องการแก้กฎทางธุรกิจ ก็ไปที่ `taskService.js` ทำให้การทำงานรวดเร็วขึ้นและลดโอกาสที่จะเกิด Bug ในส่วนที่ไม่เกี่ยวข้อง

## 3. ความท้าทายที่พบ

ความท้าทายในช่วงแรกคือการทำความเข้าใจว่า Logic ส่วนไหนควรอยู่ที่ Layer ใด และการออกแบบการส่งข้อมูลระหว่าง Layer ให้มีประสิทธิภาพ บางครั้งอาจสับสนว่าจะใส่ Validation Logic ไว้ที่ Controller หรือ Service ดี แต่สุดท้ายก็เข้าใจว่า Validation พื้นฐาน (เช่น data type, required fields) สามารถอยู่ที่ Controller/Middleware ได้ แต่ Business Rule ที่ซับซ้อนควรอยู่ที่ Service

## 4. การจัดโครงสร้างโค้ด

การแบ่ง Layer ช่วยให้โครงสร้างโค้ดดีขึ้นอย่างมากเมื่อเทียบกับ Monolithic ในสัปดาห์ที่ 3
*   **ความชัดเจน:** โค้ดถูกจัดกลุ่มตามหน้าที่ ทำให้หาเจอง่ายและเข้าใจได้เร็ว
*   **ลดการพึ่งพากัน:** แต่ละ Layer พึ่งพา Layer ที่อยู่ต่ำกว่าเท่านั้น ไม่มีการพึ่งพากันแบบสะเปะสะปะ (spaghetti code)
*   **ความเป็นอิสระ:** การเปลี่ยนแปลงใน Layer หนึ่งไม่ส่งผลกระทบต่อ Layer อื่นโดยตรง เช่น การเปลี่ยน UI (Controller) ไม่กระทบ Business Logic (Service)

## 5. เมื่อไหร่ควรใช้ Layered Architecture

Layered Architecture เหมาะสมสำหรับโปรเจกต์ส่วนใหญ่ที่มีขนาดกลางถึงใหญ่ และต้องการการบำรุงรักษาในระยะยาว โดยเฉพาะอย่างยิ่ง:
*   แอปพลิเคชันที่มี Business Logic ซับซ้อน
*   โปรเจกต์ที่พัฒนาโดยทีมหลายคน ซึ่งสามารถแบ่งงานกันตาม Layer ได้
*   โปรเจกต์ที่คาดว่าจะมีการเปลี่ยนแปลง Requirement ในอนาคต (เช่น เปลี่ยนฐานข้อมูล, เพิ่มช่องทางการเข้าถึงใหม่ๆ)

## 6. การวิเคราะห์ Trade-offs

### ข้อดี
- **Maintainability:** ดูแลรักษาง่ายมาก เพราะโค้ดถูกแบ่งเป็นส่วนๆ แก้ไขได้ตรงจุด
- **Testability:** ทดสอบง่าย สามารถเขียน Unit Test สำหรับแต่ละ Layer ได้โดยไม่ต้องพึ่งพาส่วนอื่น
- **Scalability & Flexibility:** ยืดหยุ่นต่อการเปลี่ยนแปลงและง่ายต่อการขยายระบบ

### ข้อเสีย
- **Complexity:** มีความซับซ้อนในการตั้งค่าโครงสร้างโปรเจกต์ในตอนแรก และมีจำนวนไฟล์มากกว่า
- **Performance Overhead:** อาจมี Overhead เล็กน้อยจากการเรียกฟังก์ชันข้าม Layer แต่ในทางปฏิบัติมักไม่มีนัยสำคัญ
- **Over-engineering:** อาจไม่จำเป็นสำหรับโปรเจกต์ขนาดเล็กมากๆ หรือ Prototype ที่ต้องการความรวดเร็ว

### การประเมินโดยรวม
โดยรวมแล้ว Layered Architecture เป็น Trade-off ที่คุ้มค่าสำหรับแอปพลิเคชันระดับ Production ส่วนใหญ่ ถึงแม้จะมีความซับซ้อนเพิ่มขึ้นในช่วงแรก แต่ประโยชน์ในระยะยาวด้านการบำรุงรักษา การทดสอบ และการทำงานร่วมกันในทีมนั้นมีค่ามากกว่า Overhead ที่เกิดขึ้นอย่างชัดเจน